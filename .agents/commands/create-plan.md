# Superset Execution Plans (ExecPlans)

> **DO NOT EDIT THIS FILE**
> This file is the ExecPlan template and guide only.
> Create plans in the appropriate location:
> - **Desktop app work**: `apps/desktop/plans/<timestamp>-<plan-name>.md`
> - **Web app work**: `apps/web/plans/<timestamp>-<plan-name>.md`
> - **Marketing site work**: `apps/marketing/plans/<timestamp>-<plan-name>.md`
> - **API work**: `apps/api/plans/<timestamp>-<plan-name>.md`
> - **Shared packages/cross-app work**: `plans/<timestamp>-<plan-name>.md` (root)

This document describes the requirements for an execution plan ("ExecPlan"), a design document that a coding agent can follow to deliver a working feature or system change. Treat the reader as a complete beginner to this repository: they have only the current working tree and the single ExecPlan file you provide. There is no memory of prior plans and no external context.

## Process

Steps:
1. Discovery & Orientation: map the repo, name the scope, enumerate unknowns. Capture initial Assumptions and Open Questions in the ExecPlan.
2. Question-driven Clarification: ask focused, acceptance-oriented questions grouped by plan section. Maintain the Open Questions list in the ExecPlan and pre-link each item to a Decision Log placeholder.
3. Draft the Plan: complete the ExecPlan skeleton end-to-end (Purpose, Context, Plan of Work, Validation, Idempotence, etc.), calling out risks and dependencies.
4. Resolve Questions: as answers arrive, immediately update the ExecPlan—move items from Open Questions to the Decision Log with rationale; adjust Plan of Work and Acceptance accordingly.
5. Approval Gate: present the updated ExecPlan for approval. Do not implement until approved.
6. Implementation & Validation: implement per the plan, update Progress with timestamps, and validate via tests and acceptance. Log learnings in Surprises & Discoveries.
7. Closeout: write Outcomes & Retrospective; ensure the plan remains self-contained and accurate.
8. Write your plan to the appropriate location:
   - Desktop app: `apps/desktop/plans/<timestamp>-<plan-name>.md`
   - Web app: `apps/web/plans/<timestamp>-<plan-name>.md`
   - Marketing: `apps/marketing/plans/<timestamp>-<plan-name>.md`
   - API: `apps/api/plans/<timestamp>-<plan-name>.md`
   - Cross-app/shared: `plans/<timestamp>-<plan-name>.md`
   Use `<timestamp>` in `YYYYMMDD-HHmm` format (e.g., `20260103-1045-my-feature-plan.md`). This ensures plans are sorted from most recent to oldest.
9. Plan Lifecycle: When the plan is complete and a PR is created, move it to the `done/` folder within the same directory. If abandoned, move it to `abandoned/`.

Example questions:
    I reviewed apps/desktop/src/main/lib/workspace-manager.ts to understand workspace patterns.

    Where should this new feature live?
    a) apps/desktop/src/main/lib/ (main process)
    b) apps/desktop/src/renderer/src/ (renderer process)
    c) packages/shared/ (shared across apps)
    d) Other (specify)

    How should we handle errors?
    a) Return TRPCError at boundary
    b) Use type-safe IPC error channel
    c) Other (specify)

## How to use ExecPlans

When authoring an executable specification (ExecPlan), follow this guide to the letter. Be thorough in reading (and re-reading) source material to produce an accurate specification. When creating a spec, start from the skeleton and flesh it out as you do your research.

When implementing an executable specification (ExecPlan), do not prompt the user for "next steps"; simply proceed to the next milestone. Keep all sections up to date, add or split entries in the list at every stopping point to affirmatively state the progress made and next steps. Resolve ambiguities autonomously, and commit frequently.

When discussing an executable specification (ExecPlan), record decisions in a log in the spec for posterity; it should be unambiguously clear why any change to the specification was made. ExecPlans are living documents, and it should always be possible to restart from _only_ the ExecPlan and no other work.

## Design Standards (CRITICAL)

Before drafting an ExecPlan, review the codebase standards to ensure your design aligns with established patterns:

**Always check:**
- `AGENTS.md` (root) - Architecture principles, coding conventions, code smells to avoid
- `apps/desktop/AGENTS.md` - Desktop-specific guidance (if desktop work)

**Key standards your plan must follow:**

| Category | Standard |
|----------|----------|
| **Architecture** | Separation of concerns, minimal coupling, fail-safe by default |
| **Parameters** | Functions with 2+ params use object signatures |
| **Type Safety** | No `as any`, `@ts-ignore`, or empty catch blocks |
| **Error Handling** | tRPC routers use proper error codes (NOT_FOUND, UNAUTHORIZED, etc.) |
| **Desktop** | No Node.js imports in renderer/shared code |
| **Next.js** | No `middleware.ts` (use `proxy.ts` - Next.js 16) |
| **Logging** | Prefixed with context: `[domain/operation] message` |

**When planning, verify:**
1. Does this design follow existing patterns in the codebase?
2. Are there similar implementations to reference?
3. Does the approach align with the architecture principles in AGENTS.md?
4. Have I avoided the code smells listed in AGENTS.md?

If your plan requires deviating from established patterns, document the rationale in the Decision Log and call it out explicitly for review.

## Requirements

NON-NEGOTIABLE REQUIREMENTS:

* Every ExecPlan must be fully self-contained. Self-contained means that in its current form it contains all knowledge and instructions needed for a novice to succeed.
* Every ExecPlan is a living document. Contributors are required to revise it as progress is made, as discoveries occur, and as design decisions are finalized. Each revision must remain fully self-contained.
* Every ExecPlan must enable a complete novice to implement the feature end-to-end without prior knowledge of this repo.
* Every ExecPlan must produce a demonstrably working behavior, not merely code changes to "meet a definition".
* Every ExecPlan must define every term of art in plain language or do not use it.
* Every ExecPlan must reference AGENTS.md conventions for this repository.
* Every ExecPlan must follow the design standards and coding conventions documented in AGENTS.md.

Purpose and intent come first. Begin by explaining, in a few sentences, why the work matters from a user's perspective: what someone can do after this change that they could not do before, and how to see it working. Then guide the reader through the exact steps to achieve that outcome, including what to edit, what to run, and what they should observe.

The agent executing your plan can list files, read files, search, run the project, and run tests. It does not know any prior context and cannot infer what you meant from earlier milestones. Repeat any assumption you rely on. Do not point to external blogs or docs; if knowledge is required, embed it in the plan itself in your own words.

## Superset-Specific Conventions

### Tech Stack Reference
- **Package Manager**: Bun (use `bun` not npm/yarn/pnpm)
- **Build System**: Turborepo
- **Code Quality**: Biome at root level
- **Database**: Drizzle ORM + Neon PostgreSQL
- **UI**: React + TailwindCSS v4 + shadcn/ui (in `packages/ui`)
- **Desktop**: Electron with type-safe IPC

### Common Commands
    # Development
    bun dev                    # Start all dev servers
    bun test                   # Run tests
    bun build                  # Build all packages

    # Code Quality
    bun run lint               # Check for lint issues
    bun run lint:fix           # Fix auto-fixable lint issues
    bun run typecheck          # Type check all packages

    # Database
    bun run db:push            # Apply schema changes
    bun run db:migrate         # Run migrations

### Desktop App Rules
For Electron/desktop work, remember:
- **Main process** (`src/main/`): Can use Node.js modules
- **Renderer process** (`src/renderer/`): Browser environment only, NO Node.js imports
- **IPC**: Always type-safe via `src/shared/ipc-channels.ts`
- Run `bun run lint:check-node-imports` to detect Node.js import violations

### Code Patterns
- Functions with 2+ params use object signatures: `({ param1, param2 }: { ... }) => {}`
- Follow existing patterns in AGENTS.md
- No `as any`, `@ts-ignore`, or empty catch blocks

## Formatting

Format and envelope are simple and strict. Each ExecPlan must be one markdown file. When you need to show commands, transcripts, diffs, or code, present them as indented blocks (4 spaces). Use two newlines after every heading, use # and ## and so on, and correct syntax for ordered and unordered lists.

Write in plain prose. Prefer sentences over lists. Avoid checklists, tables, and long enumerations unless brevity would obscure meaning. Checklists are permitted only in the `Progress` section, where they are mandatory. Narrative sections must remain prose-first.

## Guidelines

Self-containment and plain language are paramount. If you introduce a phrase that is not ordinary English ("IPC", "worktree", "tRPC procedure"), define it immediately and remind the reader how it manifests in this repository (for example, by naming the files or commands where it appears). Do not say "as defined previously" or "according to the architecture doc." Include the needed explanation here, even if you repeat yourself.

Anchor the plan with observable outcomes. State what the user can do after implementation, the commands to run, and the outputs they should see. Acceptance should be phrased as behavior a human can verify ("after running `bun dev`, navigating to localhost:3000/dashboard shows the new widget") rather than internal attributes ("added a DashboardWidget component"). If a change is internal, explain how its impact can still be demonstrated.

Specify repository context explicitly. Name files with full repository-relative paths, name functions and modules precisely, and describe where new files should be created. If touching multiple areas, include a short orientation paragraph that explains how those parts fit together.

Be idempotent and safe. Write the steps so they can be run multiple times without causing damage or drift. If a step can fail halfway, include how to retry or adapt.

Validation is not optional. Include instructions to run `bun run typecheck`, `bun run lint`, and `bun test` as appropriate. Describe expected outputs and error messages so a novice can tell success from failure.

## Common Failure Modes (Avoid These)

**Undefined jargon**: Using terms like "hydration", "middleware", "IPC" without defining them. If a novice wouldn't know the term, define it inline.

**Letter-of-the-law implementations**: Code that technically meets the specification but does nothing meaningful. Example: "add a button" results in a button that exists but has no handler, no styling, no integration.

**Outsourcing key decisions**: Saying "choose an appropriate library" or "implement error handling as needed" instead of being prescriptive. The plan should make these decisions explicit.

**Assuming context**: Phrases like "as we discussed", "the usual pattern", or "following the existing approach" without spelling out what that means.

**Validation theater**: Saying "verify it works" without specifying the exact command, input, and expected output.

**Incomplete state transitions**: Describing the happy path but not error cases, edge cases, or rollback scenarios.

## Milestones

When work spans multiple days or involves significant complexity, break it into milestones. Each milestone must be:

1. **Independently verifiable** - Can be tested and validated on its own
2. **Incrementally valuable** - Adds working functionality, not just scaffolding
3. **Narratively complete** - Tells a story: goal → work → result → proof

For each milestone, include:
- A brief paragraph describing the scope
- What will exist at the end that did not exist before
- The commands to run and acceptance criteria
- How to verify success before proceeding

**Example milestone structure:**

    ### Milestone 1: IPC Channel Foundation

    This milestone establishes the type-safe IPC channel for workspace operations.
    At completion, the main process can receive workspace requests and return
    typed responses, though no UI integration exists yet.

    Scope:
    - Define IpcChannels types in src/shared/ipc-channels.ts
    - Implement handler in src/main/lib/workspace-ipcs.ts
    - Add unit tests for the handler

    Acceptance:
        bun test apps/desktop/src/main/lib/workspace-ipcs.test.ts
        # Expected: All tests pass

    Verify before proceeding: Types compile, tests pass, handler logs correctly.

Progress tracks granular tasks; milestones tell the story. Both must exist for complex plans.

## Prototyping & Spike Milestones

When facing significant unknowns or risky technical decisions, include explicit prototyping milestones to de-risk before full implementation.

**When to use spikes:**
- Evaluating an unfamiliar library or API
- Validating that a proposed approach is feasible
- Comparing two implementation strategies
- Testing performance characteristics before committing

**Spike structure:**

    ### Spike: Evaluate node-pty vs xterm.js for terminal rendering

    Goal: Determine which library better suits our terminal requirements.

    Approach:
    - Create minimal implementations with each library
    - Test: resize handling, Unicode support, performance with large output
    - Measure: memory usage, CPU during rapid output

    Success criteria:
    - One library clearly outperforms on our key requirements
    - OR: Both are viable with documented tradeoffs for Decision Log

    Outcome: [To be filled after spike completes]

**Guidelines for spikes:**
- Keep them additive and isolated (don't modify production code)
- Set a time box (e.g., "2 hours max")
- Document findings in Surprises & Discoveries
- Record the decision in Decision Log with evidence

## Parallel Implementations & Safe Refactoring

When migrating or refactoring, prefer patterns that keep the codebase working throughout:

**Additive-then-subtractive**: Add new code alongside old code, verify tests pass with both, then remove old code. Never delete-then-replace in a single step.

**Parallel implementations**: During migrations, keep both the old adapter and new implementation running. Validate both paths work, then retire the old one with tests proving equivalence.

**Feature flags**: For risky changes, consider implementing behind a flag so rollback is a config change, not a code revert.

    Example: Migrating from REST to tRPC

    1. Add tRPC endpoint alongside existing REST endpoint
    2. Update one caller to use tRPC, verify it works
    3. Gradually migrate remaining callers
    4. Remove REST endpoint only after all callers migrated and tested

Document parallel implementation strategies in the Plan of Work and include cleanup steps.

## Skeleton of a Good ExecPlan

    # <Short, action-oriented description>

    This ExecPlan is a living document. The sections `Progress`, `Surprises & Discoveries`, `Decision Log`, and `Outcomes & Retrospective` must be kept up to date as work proceeds.

    Reference: This plan follows conventions from AGENTS.md and this template.

    ## Purpose / Big Picture

    Explain in a few sentences what someone gains after this change and how they can see it working. State the user-visible behavior you will enable.

    ## Assumptions

    State temporary assumptions that unblock planning. Every assumption must either be confirmed (moved to the Decision Log) or removed by implementation end.

    ## Open Questions

    List unresolved, acceptance-oriented questions. For each, note the impacted plan sections (e.g., Validation, Plan of Work) and add a placeholder in the Decision Log for the eventual answer.

    ## Progress

    Use a list with checkboxes to summarize granular steps. Every stopping point must be documented here, even if it requires splitting a partially completed task into two ("done" vs. "remaining"). This section must always reflect the actual current state of the work.

    - [x] (2026-01-03 13:00Z) Example completed step.
    - [ ] Example incomplete step.
    - [ ] Example partially completed step (completed: X; remaining: Y).

    Use timestamps to measure rates of progress.

    ## Surprises & Discoveries

    Document unexpected behaviors, bugs, optimizations, or insights discovered during implementation. Provide concise evidence.

    - Observation: ...
      Evidence: ...

    ## Decision Log

    Record every decision made while working on the plan in the format:

    - Decision: ...
      Rationale: ...
      Date/Author: ...

    ## Outcomes & Retrospective

    Summarize outcomes, gaps, and lessons learned at major milestones or at completion. Compare the result against the original purpose.

    ## Context and Orientation

    Describe the current state relevant to this task as if the reader knows nothing. Name the key files and modules by full path. Define any non-obvious term you will use. Do not refer to prior plans.

    For this Superset monorepo, always mention:
    - Which app(s) are affected (desktop, web, marketing, api, admin, docs)
    - Which packages are involved (db, ui, shared, trpc, queries, local-db)
    - Any IPC channels if desktop work is involved

    ## Plan of Work

    Describe, in prose, the sequence of edits and additions. For each edit, name the file and location (function, module) and what to insert or change. Keep it concrete and minimal.

    ## Concrete Steps

    State the exact commands to run and where to run them (working directory). When a command generates output, show a short expected transcript so the reader can compare.

        cd apps/desktop
        bun run typecheck
        # Expected: No errors

    ## Validation and Acceptance

    Describe how to start or exercise the system and what to observe.

    For desktop app changes:
        bun dev
        # Desktop app opens, navigate to [feature], observe [behavior]

    For web app changes:
        bun dev
        # Navigate to localhost:3000/[route], observe [behavior]

    Run validation commands:
        bun run typecheck   # No type errors
        bun run lint        # No lint errors
        bun test            # All tests pass

    ## Idempotence and Recovery

    If steps can be repeated safely, say so. If a step is risky, provide a safe retry or rollback path.

    ## Artifacts and Notes

    Include the most important transcripts, diffs, or snippets as indented examples. Keep them concise and focused on what proves success.

    ## Interfaces and Dependencies

    Be prescriptive. Name the libraries, modules, and services to use and why. Specify the types and function signatures that must exist at the end of the milestone.

    For IPC channels (desktop), define in apps/desktop/src/shared/ipc-channels.ts:

        export interface IpcChannels {
          "my-new-channel": {
            request: { param1: string };
            response: { success: boolean; data: MyData };
          };
        }

If you follow the guidance above, a single, stateless agent -- or a human novice -- can read your ExecPlan from top to bottom and produce a working, observable result. That is the bar: SELF-CONTAINED, SELF-SUFFICIENT, NOVICE-GUIDING, OUTCOME-FOCUSED.

When you revise a plan, you must ensure your changes are comprehensively reflected across all sections, including the living document sections, and you must write a note at the bottom of the plan describing the change and the reason why. ExecPlans must describe not just the what but the why for almost everything.

## Plan Lifecycle

ExecPlans have a defined lifecycle that keeps the plans folders clean and provides a historical record of completed work.

### Directory Structure

    apps/desktop/plans/        # Desktop app plans
    ├── <active-plans>.md
    ├── done/
    └── abandoned/

    apps/web/plans/            # Web app plans
    ├── <active-plans>.md
    ├── done/
    └── abandoned/

    plans/                     # Cross-app/shared plans
    ├── <active-plans>.md
    ├── done/
    └── abandoned/

### When to Move Plans

**To `done/`**: Move the plan to the `done/` folder within the same directory when creating a PR that completes the work. Before moving, ensure the plan's `Outcomes & Retrospective` section is filled in.

**To `abandoned/`**: Move the plan to the `abandoned/` folder within the same directory if work is stopped without completion. Add a note explaining why (scope changed, approach invalidated, deprioritized, etc.).

### Edge Cases

- **PR closed without merging**: The plan stays in `done/`. If work resumes, move it back to the active plans folder and update the `Progress` section.
- **Plan spans multiple PRs**: Keep the plan in the active folder until the final PR. Reference intermediate PRs in the `Progress` section, then move to `done/` on the final PR.
- **Reopening abandoned work**: Move the plan from `abandoned/` back to the active plans folder and update the `Progress` section to reflect the restart.
