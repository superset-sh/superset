import { randomUUID } from "node:crypto";
import { existsSync } from "node:fs";

import type {
	CreateTabInput,
	CreateWorkspaceInput,
	CreateWorktreeInput,
	Tab,
	UpdateWorkspaceInput,
	Workspace,
	Worktree,
} from "shared/types";

import configManager from "./config-manager";
import worktreeManager from "./worktree-manager";

// Function to create default tabs for a 2x2 grid layout
function createDefaultTabs(): Tab[] {
	const now = new Date().toISOString();
	const cols = 2; // 2x2 grid
	return [
		{
			id: randomUUID(),
			name: "Terminal 1",
			type: "terminal",
			order: 0,
			row: 0, // floor(0 / 2) = 0
			col: 0, // 0 % 2 = 0
			command: null,
			createdAt: now,
		},
		{
			id: randomUUID(),
			name: "Terminal 2",
			type: "terminal",
			order: 1,
			row: 0, // floor(1 / 2) = 0
			col: 1, // 1 % 2 = 1
			command: null,
			createdAt: now,
		},
		{
			id: randomUUID(),
			name: "Terminal 3",
			type: "terminal",
			order: 2,
			row: 1, // floor(2 / 2) = 1
			col: 0, // 2 % 2 = 0
			command: null,
			createdAt: now,
		},
		{
			id: randomUUID(),
			name: "Terminal 4",
			type: "terminal",
			order: 3,
			row: 1, // floor(3 / 2) = 1
			col: 1, // 3 % 2 = 1
			command: null,
			createdAt: now,
		},
	];
}

class WorkspaceManager {
	private static instance: WorkspaceManager;

	private constructor() {}

	static getInstance(): WorkspaceManager {
		if (!WorkspaceManager.instance) {
			WorkspaceManager.instance = new WorkspaceManager();
		}
		return WorkspaceManager.instance;
	}

	/**
	 * Get all workspaces
	 */
	async list(): Promise<Workspace[]> {
		const config = configManager.read();
		return config.workspaces;
	}

	/**
	 * Get a workspace by ID
	 */
	async get(id: string): Promise<Workspace | null> {
		const config = configManager.read();
		return config.workspaces.find((ws) => ws.id === id) || null;
	}

	/**
	 * Create a new workspace (container for worktrees)
	 */
	async create(
		input: CreateWorkspaceInput,
	): Promise<{ success: boolean; workspace?: Workspace; error?: string }> {
		try {
			// Validate that repoPath is a git repository
			if (!worktreeManager.isGitRepo(input.repoPath)) {
				return {
					success: false,
					error: "The specified path is not a git repository",
				};
			}

			// Create workspace object - starts with no worktrees
			const now = new Date().toISOString();
			const workspace: Workspace = {
				id: randomUUID(),
				name: input.name,
				repoPath: input.repoPath,
				branch: input.branch,
				worktrees: [],
				activeWorktreeId: null,
				activeTabId: null,
				createdAt: now,
				updatedAt: now,
			};

			// Save to config
			const config = configManager.read();
			config.workspaces.push(workspace);
			const saved = configManager.write(config);

			if (!saved) {
				return {
					success: false,
					error: "Failed to save workspace configuration",
				};
			}

			// Set as last opened workspace
			configManager.setLastOpenedWorkspaceId(workspace.id);

			return {
				success: true,
				workspace,
			};
		} catch (error) {
			console.error("Failed to create workspace:", error);
			return {
				success: false,
				error: error instanceof Error ? error.message : String(error),
			};
		}
	}

	/**
	 * Create a new worktree with a default tab group and tab
	 */
	async createWorktree(
		input: CreateWorktreeInput,
	): Promise<{ success: boolean; worktree?: Worktree; error?: string }> {
		try {
			const workspace = await this.get(input.workspaceId);
			if (!workspace) {
				return { success: false, error: "Workspace not found" };
			}

			// Create git worktree
			const worktreeResult = await worktreeManager.createWorktree(
				workspace.repoPath,
				input.branch,
				input.createBranch || false,
			);

			if (!worktreeResult.success) {
				return {
					success: false,
					error: `Failed to create worktree: ${worktreeResult.error}`,
				};
			}

			// Create default tabs for 2x2 layout
			const now = new Date().toISOString();
			const defaultTabs = createDefaultTabs();

			// Create default group tab with 4 terminal tabs in 2x2 grid
			const defaultGroupTab: Tab = {
				id: randomUUID(),
				name: "Default",
				type: "group",
				tabs: defaultTabs,
				rows: 2,
				cols: 2,
				createdAt: now,
			};

			// Create worktree object
			const worktree: Worktree = {
				id: randomUUID(),
				branch: input.branch,
				path: worktreeResult.path!,
				tabs: [defaultGroupTab],
				createdAt: now,
			};

			// Add to workspace
			workspace.worktrees.push(worktree);
			workspace.updatedAt = now;

			// Save
			const config = configManager.read();
			const index = config.workspaces.findIndex((ws) => ws.id === workspace.id);
			if (index !== -1) {
				config.workspaces[index] = workspace;
				configManager.write(config);
			}

			return { success: true, worktree };
		} catch (error) {
			console.error("Failed to create worktree:", error);
			return {
				success: false,
				error: error instanceof Error ? error.message : String(error),
			};
		}
	}

	/**
	 * Helper to find a tab by ID recursively
	 */
	private findTab(tabs: Tab[], tabId: string): Tab | null {
		for (const tab of tabs) {
			if (tab.id === tabId) {
				return tab;
			}
			if (tab.type === "group" && tab.tabs) {
				const found = this.findTab(tab.tabs, tabId);
				if (found) return found;
			}
		}
		return null;
	}

	/**
	 * Helper to find parent tab of a given tab ID
	 */
	private findParentTab(tabs: Tab[], tabId: string): Tab | null {
		for (const tab of tabs) {
			if (tab.type === "group" && tab.tabs) {
				if (tab.tabs.some((t) => t.id === tabId)) {
					return tab;
				}
				const found = this.findParentTab(tab.tabs, tabId);
				if (found) return found;
			}
		}
		return null;
	}

	/**
	 * Create a new tab in a worktree or inside a parent tab
	 */
	async createTab(
		input: CreateTabInput,
	): Promise<{ success: boolean; tab?: Tab; error?: string }> {
		try {
			const workspace = await this.get(input.workspaceId);
			if (!workspace) {
				return { success: false, error: "Workspace not found" };
			}

			const worktree = workspace.worktrees.find(
				(wt) => wt.id === input.worktreeId,
			);
			if (!worktree) {
				return { success: false, error: "Worktree not found" };
			}

			const tab: Tab = {
				id: randomUUID(),
				name: input.name,
				type: input.type || "terminal", // Default to terminal if not specified
				createdAt: new Date().toISOString(),
			};

			// Type-specific properties
			if (tab.type === "terminal") {
				tab.command = input.command;
			} else if (tab.type === "group") {
				tab.tabs = [];
				tab.rows = input.rows || 2;
				tab.cols = input.cols || 2;
			}

			// Position properties (for tabs inside a group)
			if (input.parentTabId) {
				const parentTab = this.findTab(worktree.tabs, input.parentTabId);
				if (!parentTab || parentTab.type !== "group") {
					return { success: false, error: "Parent tab not found or not a group" };
				}

				if (input.row !== undefined && input.col !== undefined && parentTab.cols) {
					tab.order = input.row * parentTab.cols + input.col;
					tab.row = input.row;
					tab.col = input.col;
				}
				tab.rowSpan = input.rowSpan;
				tab.colSpan = input.colSpan;

				parentTab.tabs = parentTab.tabs || [];
				parentTab.tabs.push(tab);
			} else {
				// Top-level tab in worktree
				worktree.tabs.push(tab);
			}

			workspace.updatedAt = new Date().toISOString();

			// Save
			const config = configManager.read();
			const index = config.workspaces.findIndex((ws) => ws.id === workspace.id);
			if (index !== -1) {
				config.workspaces[index] = workspace;
				configManager.write(config);
			}

			return { success: true, tab };
		} catch (error) {
			console.error("Failed to create tab:", error);
			return {
				success: false,
				error: error instanceof Error ? error.message : String(error),
			};
		}
	}

	async deleteTab(input: {
		workspaceId: string;
		worktreeId: string;
		tabId: string;
	}): Promise<{ success: boolean; error?: string }> {
		try {
			const workspace = await this.get(input.workspaceId);
			if (!workspace) {
				return { success: false, error: "Workspace not found" };
			}

			const worktree = workspace.worktrees.find(
				(wt) => wt.id === input.worktreeId,
			);
			if (!worktree) {
				return { success: false, error: "Worktree not found" };
			}

			// Helper function to remove tab recursively
			const removeTab = (tabs: Tab[]): boolean => {
				const tabIndex = tabs.findIndex((t) => t.id === input.tabId);
				if (tabIndex !== -1) {
					tabs.splice(tabIndex, 1);
					return true;
				}

				// Search in nested tabs
				for (const tab of tabs) {
					if (tab.type === "group" && tab.tabs) {
						if (removeTab(tab.tabs)) {
							// Recalculate grid positions for remaining tabs
							if (tab.cols) {
								tab.tabs = tab.tabs.map((childTab, index) => {
									const row = Math.floor(index / (tab.cols || 2));
									const col = index % (tab.cols || 2);
									return { ...childTab, order: index, row, col };
								});
							}
							return true;
						}
					}
				}
				return false;
			};

			if (!removeTab(worktree.tabs)) {
				return { success: false, error: "Tab not found" };
			}

			workspace.updatedAt = new Date().toISOString();

			// Save
			const config = configManager.read();
			const index = config.workspaces.findIndex((ws) => ws.id === workspace.id);
			if (index !== -1) {
				config.workspaces[index] = workspace;
				configManager.write(config);
			}

			return { success: true };
		} catch (error) {
			console.error("Failed to delete tab:", error);
			return {
				success: false,
				error: error instanceof Error ? error.message : String(error),
			};
		}
	}

	/**
	 * Get the last opened workspace
	 */
	async getLastOpened(): Promise<Workspace | null> {
		const lastId = configManager.getLastOpenedWorkspaceId();
		if (!lastId) return null;
		return await this.get(lastId);
	}

	/**
	 * Update a workspace
	 */
	async update(
		input: UpdateWorkspaceInput,
	): Promise<{ success: boolean; workspace?: Workspace; error?: string }> {
		try {
			const config = configManager.read();
			const index = config.workspaces.findIndex((ws) => ws.id === input.id);

			if (index === -1) {
				return {
					success: false,
					error: "Workspace not found",
				};
			}

			// Update workspace
			const workspace = config.workspaces[index];
			if (input.name) workspace.name = input.name;
			workspace.updatedAt = new Date().toISOString();

			config.workspaces[index] = workspace;
			const saved = configManager.write(config);

			if (!saved) {
				return {
					success: false,
					error: "Failed to save workspace configuration",
				};
			}

			return {
				success: true,
				workspace,
			};
		} catch (error) {
			console.error("Failed to update workspace:", error);
			return {
				success: false,
				error: error instanceof Error ? error.message : String(error),
			};
		}
	}

	/**
	 * Delete a workspace
	 */
	async delete(
		id: string,
		removeWorktree = false,
	): Promise<{ success: boolean; error?: string }> {
		try {
			const config = configManager.read();
			const workspace = config.workspaces.find((ws) => ws.id === id);

			if (!workspace) {
				return {
					success: false,
					error: "Workspace not found",
				};
			}

			// Optionally remove worktree
			if (removeWorktree) {
				const worktreePath = worktreeManager.getWorktreePath(
					workspace.repoPath,
					workspace.branch,
				);
				await worktreeManager.removeWorktree(workspace.repoPath, worktreePath);
			}

			// Remove from config
			config.workspaces = config.workspaces.filter((ws) => ws.id !== id);
			const saved = configManager.write(config);

			if (!saved) {
				return {
					success: false,
					error: "Failed to save workspace configuration",
				};
			}

			return { success: true };
		} catch (error) {
			console.error("Failed to delete workspace:", error);
			return {
				success: false,
				error: error instanceof Error ? error.message : String(error),
			};
		}
	}

	/**
	 * Get a tab by ID
	 */
	getTab(
		workspaceId: string,
		worktreeId: string,
		tabGroupId: string,
		tabId: string,
	): Tab | null {
		const config = configManager.read();
		const workspace = config.workspaces.find((ws) => ws.id === workspaceId);
		if (!workspace) return null;

		const worktree = workspace.worktrees.find((wt) => wt.id === worktreeId);
		if (!worktree) return null;

		const tabGroup = worktree.tabGroups.find((tg) => tg.id === tabGroupId);
		if (!tabGroup) return null;

		return tabGroup.tabs.find((t) => t.id === tabId) || null;
	}

	/**
	 * Update terminal CWD in a tab (tab now IS the terminal)
	 */
	updateTerminalCwd(
		workspaceId: string,
		worktreeId: string,
		tabGroupId: string,
		tabId: string,
		cwd: string,
	): boolean {
		try {
			const config = configManager.read();
			const workspace = config.workspaces.find((ws) => ws.id === workspaceId);
			if (!workspace) return false;

			const worktree = workspace.worktrees.find((wt) => wt.id === worktreeId);
			if (!worktree) return false;

			const tabGroup = worktree.tabGroups.find((tg) => tg.id === tabGroupId);
			if (!tabGroup) return false;

			const tab = tabGroup.tabs.find((t) => t.id === tabId);
			if (!tab) return false;

			// Update CWD on the tab itself (tab is the terminal)
			tab.cwd = cwd;
			workspace.updatedAt = new Date().toISOString();

			// Save to config
			const index = config.workspaces.findIndex((ws) => ws.id === workspaceId);
			if (index !== -1) {
				config.workspaces[index] = workspace;
				return configManager.write(config);
			}

			return false;
		} catch (error) {
			console.error("Failed to update terminal CWD:", error);
			return false;
		}
	}

	/**
	 * Scan and import existing git worktrees for a workspace
	 */
	async scanAndImportWorktrees(
		workspaceId: string,
	): Promise<{ success: boolean; imported?: number; error?: string }> {
		try {
			const workspace = await this.get(workspaceId);
			if (!workspace) {
				return { success: false, error: "Workspace not found" };
			}

			// Get all git worktrees from the repository
			const gitWorktrees = worktreeManager.listWorktrees(workspace.repoPath);

			// Include all worktrees (including main repo) that actually exist on filesystem
			const allWorktrees = gitWorktrees.filter(
				(wt) => !wt.bare && existsSync(wt.path),
			);

			// Create a set of valid worktree paths for quick lookup
			const validWorktreePaths = new Set(allWorktrees.map((wt) => wt.path));

			let importedCount = 0;
			let configChanged = false;
			const now = new Date().toISOString();

			// Remove worktrees that no longer exist (either not in git or not on filesystem)
			const initialWorktreeCount = workspace.worktrees.length;
			workspace.worktrees = workspace.worktrees.filter((wt) => {
				// Remove if not in git's worktree list OR if path doesn't exist on filesystem
				if (!validWorktreePaths.has(wt.path) || !existsSync(wt.path)) {
					configChanged = true;
					return false;
				}
				return true;
			});
			const removedCount = initialWorktreeCount - workspace.worktrees.length;

			for (const gitWorktree of allWorktrees) {
				// Get the actual current branch for this worktree path
				const currentBranch =
					worktreeManager.getCurrentBranch(gitWorktree.path) ||
					gitWorktree.branch;

				// Check if this worktree is already in our workspace
				const existingWorktree = workspace.worktrees.find(
					(wt) => wt.path === gitWorktree.path,
				);

				if (existingWorktree) {
					// Update the branch if it has changed
					if (existingWorktree.branch !== currentBranch) {
						existingWorktree.branch = currentBranch;
						importedCount++;
						configChanged = true;
					}
				} else {
					// Create default tabs for 2x2 layout
					const defaultTabs = createDefaultTabs();

					// Create default tab group with 4 tabs in 2x2 grid
					const defaultTabGroup: TabGroup = {
						id: randomUUID(),
						name: "Default",
						tabs: defaultTabs,
						rows: 2,
						cols: 2,
						createdAt: now,
					};

					// Create worktree object
					const worktree: Worktree = {
						id: randomUUID(),
						branch: currentBranch,
						path: gitWorktree.path,
						tabGroups: [defaultTabGroup],
						createdAt: now,
					};

					workspace.worktrees.push(worktree);
					importedCount++;
					configChanged = true;
				}
			}

			if (configChanged) {
				workspace.updatedAt = now;

				// Save to config
				const config = configManager.read();
				const index = config.workspaces.findIndex(
					(ws) => ws.id === workspace.id,
				);
				if (index !== -1) {
					config.workspaces[index] = workspace;
					configManager.write(config);
				}
			}

			if (removedCount > 0) {
				console.log(`Removed ${removedCount} deleted worktree(s) from config`);
			}

			return { success: true, imported: importedCount };
		} catch (error) {
			console.error("Failed to scan and import worktrees:", error);
			return {
				success: false,
				error: error instanceof Error ? error.message : String(error),
			};
		}
	}

	/**
	 * Reorder tabs within a tab group
	 */
	async reorderTabs(
		workspaceId: string,
		worktreeId: string,
		tabGroupId: string,
		tabIds: string[],
	): Promise<{ success: boolean; error?: string }> {
		try {
			const config = configManager.read();
			const workspace = config.workspaces.find((ws) => ws.id === workspaceId);
			if (!workspace) {
				return { success: false, error: "Workspace not found" };
			}

			const worktree = workspace.worktrees.find((wt) => wt.id === worktreeId);
			if (!worktree) {
				return { success: false, error: "Worktree not found" };
			}

			const tabGroup = worktree.tabGroups.find((tg) => tg.id === tabGroupId);
			if (!tabGroup) {
				return { success: false, error: "Tab group not found" };
			}

			// Reorder tabs based on tabIds array
			const reorderedTabs = tabIds
				.map((id) => tabGroup.tabs.find((t) => t.id === id))
				.filter((t): t is Tab => t !== undefined);

			// Verify all tabs are accounted for
			if (reorderedTabs.length !== tabGroup.tabs.length) {
				return { success: false, error: "Invalid tab order" };
			}

			// Recalculate grid positions based on new order
			const tabsWithUpdatedPositions = reorderedTabs.map((tab, index) => {
				const row = Math.floor(index / tabGroup.cols);
				const col = index % tabGroup.cols;
				return { ...tab, row, col };
			});

			tabGroup.tabs = tabsWithUpdatedPositions;
			workspace.updatedAt = new Date().toISOString();

			// Save to config
			const index = config.workspaces.findIndex((ws) => ws.id === workspaceId);
			if (index !== -1) {
				config.workspaces[index] = workspace;
				configManager.write(config);
			}

			return { success: true };
		} catch (error) {
			console.error("Failed to reorder tabs:", error);
			return {
				success: false,
				error: error instanceof Error ? error.message : String(error),
			};
		}
	}

	/**
	 * Reorder tab groups within a worktree
	 */
	async reorderTabGroups(
		workspaceId: string,
		worktreeId: string,
		tabGroupIds: string[],
	): Promise<{ success: boolean; error?: string }> {
		try {
			const config = configManager.read();
			const workspace = config.workspaces.find((ws) => ws.id === workspaceId);
			if (!workspace) {
				return { success: false, error: "Workspace not found" };
			}

			const worktree = workspace.worktrees.find((wt) => wt.id === worktreeId);
			if (!worktree) {
				return { success: false, error: "Worktree not found" };
			}

			// Reorder tab groups based on tabGroupIds array
			const reorderedTabGroups = tabGroupIds
				.map((id) => worktree.tabGroups.find((tg) => tg.id === id))
				.filter((tg): tg is TabGroup => tg !== undefined);

			// Verify all tab groups are accounted for
			if (reorderedTabGroups.length !== worktree.tabGroups.length) {
				return { success: false, error: "Invalid tab group order" };
			}

			worktree.tabGroups = reorderedTabGroups;
			workspace.updatedAt = new Date().toISOString();

			// Save to config
			const index = config.workspaces.findIndex((ws) => ws.id === workspaceId);
			if (index !== -1) {
				config.workspaces[index] = workspace;
				configManager.write(config);
			}

			return { success: true };
		} catch (error) {
			console.error("Failed to reorder tab groups:", error);
			return {
				success: false,
				error: error instanceof Error ? error.message : String(error),
			};
		}
	}

	/**
	 * Update tab group grid sizes (row and column sizes)
	 */
	async updateTabGroupGridSizes(
		workspaceId: string,
		worktreeId: string,
		tabGroupId: string,
		rowSizes?: number[],
		colSizes?: number[],
	): Promise<{ success: boolean; error?: string }> {
		try {
			const config = configManager.read();
			const workspace = config.workspaces.find((ws) => ws.id === workspaceId);
			if (!workspace) {
				return { success: false, error: "Workspace not found" };
			}

			const worktree = workspace.worktrees.find((wt) => wt.id === worktreeId);
			if (!worktree) {
				return { success: false, error: "Worktree not found" };
			}

			const tabGroup = worktree.tabGroups.find((tg) => tg.id === tabGroupId);
			if (!tabGroup) {
				return { success: false, error: "Tab group not found" };
			}

			// Update grid sizes
			if (rowSizes !== undefined) {
				tabGroup.rowSizes = rowSizes;
			}
			if (colSizes !== undefined) {
				tabGroup.colSizes = colSizes;
			}

			workspace.updatedAt = new Date().toISOString();

			// Save to config
			const index = config.workspaces.findIndex((ws) => ws.id === workspaceId);
			if (index !== -1) {
				config.workspaces[index] = workspace;
				configManager.write(config);
			}

			return { success: true };
		} catch (error) {
			console.error("Failed to update tab group grid sizes:", error);
			return {
				success: false,
				error: error instanceof Error ? error.message : String(error),
			};
		}
	}

	/**
	 * Move a tab from one tab group to another
	 */
	async moveTabToGroup(
		workspaceId: string,
		worktreeId: string,
		tabId: string,
		sourceTabGroupId: string,
		targetTabGroupId: string,
		targetIndex: number,
	): Promise<{ success: boolean; error?: string }> {
		try {
			const config = configManager.read();
			const workspace = config.workspaces.find((ws) => ws.id === workspaceId);
			if (!workspace) {
				return { success: false, error: "Workspace not found" };
			}

			const worktree = workspace.worktrees.find((wt) => wt.id === worktreeId);
			if (!worktree) {
				return { success: false, error: "Worktree not found" };
			}

			const sourceTabGroup = worktree.tabGroups.find(
				(tg) => tg.id === sourceTabGroupId,
			);
			const targetTabGroup = worktree.tabGroups.find(
				(tg) => tg.id === targetTabGroupId,
			);

			if (!sourceTabGroup || !targetTabGroup) {
				return { success: false, error: "Tab group not found" };
			}

			// Find and remove tab from source group
			const tabIndex = sourceTabGroup.tabs.findIndex((t) => t.id === tabId);
			if (tabIndex === -1) {
				return { success: false, error: "Tab not found in source group" };
			}

			const [tab] = sourceTabGroup.tabs.splice(tabIndex, 1);

			// Insert tab into target group at specified index
			targetTabGroup.tabs.splice(targetIndex, 0, tab);

			// Recalculate grid positions for both groups
			sourceTabGroup.tabs = sourceTabGroup.tabs.map((t, index) => {
				const row = Math.floor(index / sourceTabGroup.cols);
				const col = index % sourceTabGroup.cols;
				return { ...t, row, col };
			});

			targetTabGroup.tabs = targetTabGroup.tabs.map((t, index) => {
				const row = Math.floor(index / targetTabGroup.cols);
				const col = index % targetTabGroup.cols;
				return { ...t, row, col };
			});

			workspace.updatedAt = new Date().toISOString();

			// Save to config
			const index = config.workspaces.findIndex((ws) => ws.id === workspaceId);
			if (index !== -1) {
				config.workspaces[index] = workspace;
				configManager.write(config);
			}

			return { success: true };
		} catch (error) {
			console.error("Failed to move tab to group:", error);
			return {
				success: false,
				error: error instanceof Error ? error.message : String(error),
			};
		}
	}

	/**
	 * Remove a worktree
	 */
	async removeWorktree(
		workspaceId: string,
		worktreeId: string,
	): Promise<{ success: boolean; error?: string }> {
		try {
			const workspace = await this.get(workspaceId);
			if (!workspace) {
				return { success: false, error: "Workspace not found" };
			}

			const worktree = workspace.worktrees.find((wt) => wt.id === worktreeId);
			if (!worktree) {
				return { success: false, error: "Worktree not found" };
			}

			// Remove git worktree
			await worktreeManager.removeWorktree(workspace.repoPath, worktree.path);

			// Remove from workspace
			workspace.worktrees = workspace.worktrees.filter(
				(wt) => wt.id !== worktreeId,
			);
			workspace.updatedAt = new Date().toISOString();

			// Save to config
			const config = configManager.read();
			const index = config.workspaces.findIndex((ws) => ws.id === workspace.id);
			if (index !== -1) {
				config.workspaces[index] = workspace;
				configManager.write(config);
			}

			return { success: true };
		} catch (error) {
			console.error("Failed to remove worktree:", error);
			return {
				success: false,
				error: error instanceof Error ? error.message : String(error),
			};
		}
	}

	/**
	 * Check if a worktree can be merged into the active worktree
	 */
	async canMergeWorktree(
		workspaceId: string,
		worktreeId: string,
	): Promise<{
		success: boolean;
		canMerge?: boolean;
		reason?: string;
		error?: string;
		isActiveWorktree?: boolean;
		hasUncommittedChanges?: boolean;
	}> {
		try {
			const workspace = await this.get(workspaceId);
			if (!workspace) {
				return { success: false, error: "Workspace not found" };
			}

			const worktree = workspace.worktrees.find((wt) => wt.id === worktreeId);
			if (!worktree) {
				return { success: false, error: "Worktree not found" };
			}

			// Check if this is the active worktree
			if (workspace.activeWorktreeId === worktreeId) {
				return {
					success: true,
					canMerge: false,
					reason: "Cannot merge the active worktree into itself",
					isActiveWorktree: true,
				};
			}

			// Find the active worktree
			const activeWorktree = workspace.worktrees.find(
				(wt) => wt.id === workspace.activeWorktreeId,
			);
			if (!activeWorktree) {
				return {
					success: true,
					canMerge: false,
					reason: "No active worktree found",
				};
			}

			// Check if the source branch can be merged into the active worktree
			const canMerge = await worktreeManager.canMerge(
				activeWorktree.path,
				worktree.branch,
			);

			return {
				success: true,
				canMerge: canMerge.canMerge,
				reason: canMerge.reason,
				hasUncommittedChanges: canMerge.hasUncommittedChanges,
				isActiveWorktree: false,
			};
		} catch (error) {
			console.error("Failed to check if worktree can be merged:", error);
			return {
				success: false,
				error: error instanceof Error ? error.message : String(error),
			};
		}
	}

	/**
	 * Merge a worktree into the active worktree
	 */
	async mergeWorktree(
		workspaceId: string,
		worktreeId: string,
	): Promise<{ success: boolean; error?: string }> {
		try {
			const workspace = await this.get(workspaceId);
			if (!workspace) {
				return { success: false, error: "Workspace not found" };
			}

			const worktree = workspace.worktrees.find((wt) => wt.id === worktreeId);
			if (!worktree) {
				return { success: false, error: "Worktree not found" };
			}

			// Check if this is the active worktree
			if (workspace.activeWorktreeId === worktreeId) {
				return {
					success: false,
					error: "Cannot merge the active worktree into itself",
				};
			}

			// Find the active worktree
			const activeWorktree = workspace.worktrees.find(
				(wt) => wt.id === workspace.activeWorktreeId,
			);
			if (!activeWorktree) {
				return { success: false, error: "No active worktree found" };
			}

			// Merge the source branch into the active worktree
			const result = await worktreeManager.merge(
				activeWorktree.path,
				worktree.branch,
			);

			if (!result.success) {
				return { success: false, error: result.error };
			}

			return { success: true };
		} catch (error) {
			console.error("Failed to merge worktree:", error);
			return {
				success: false,
				error: error instanceof Error ? error.message : String(error),
			};
		}
	}

	/**
	 * Get the path of a worktree
	 */
	async getWorktreePath(
		workspaceId: string,
		worktreeId: string,
	): Promise<string | null> {
		const workspace = await this.get(workspaceId);
		if (!workspace) return null;

		const worktree = workspace.worktrees.find((wt) => wt.id === worktreeId);
		return worktree?.path || null;
	}
}

export default WorkspaceManager.getInstance();
