import { useState } from "react";
import type { Worktree } from "shared/types";
import type { TaskStatus } from "../components/Layout/StatusIndicator";
import type { UITask, PendingWorktree } from "../types";
import { MOCK_TASKS } from "../constants";

interface UseTasksProps {
	currentWorkspace: {
		id: string;
		worktrees?: Worktree[];
	} | null;
	setSelectedWorktreeId: (id: string | null) => void;
	handleTabSelect: (worktreeId: string, tabId: string) => void;
	handleWorktreeCreated: () => Promise<void>;
}

export function useTasks({
	currentWorkspace,
	setSelectedWorktreeId,
	handleTabSelect,
	handleWorktreeCreated,
}: UseTasksProps) {
	const [isAddTaskModalOpen, setIsAddTaskModalOpen] = useState(false);
	const [pendingWorktrees, setPendingWorktrees] = useState<PendingWorktree[]>(
		[],
	);

	// Compute which tasks have worktrees (are "open")
	const openTasks = MOCK_TASKS.filter((task) =>
		currentWorkspace?.worktrees?.some((wt) => wt.branch === task.branch),
	);

	const handleOpenAddTaskModal = () => {
		setIsAddTaskModalOpen(true);
	};

	const handleCloseAddTaskModal = () => {
		setIsAddTaskModalOpen(false);
	};

	const handleSelectTask = (task: UITask) => {
		if (!currentWorkspace) return;

		// Find existing worktree for this task's branch
		const existingWorktree = currentWorkspace.worktrees?.find(
			(wt) => wt.branch === task.branch,
		);

		if (existingWorktree) {
			// Worktree already exists - switch to it
			setSelectedWorktreeId(existingWorktree.id);
			if (existingWorktree.tabs && existingWorktree.tabs.length > 0) {
				handleTabSelect(existingWorktree.id, existingWorktree.tabs[0].id);
			}
			handleCloseAddTaskModal();
		} else {
			// Worktree doesn't exist - create it with optimistic update
			const pendingId = `pending-${Date.now()}`;
			const pendingWorktree: PendingWorktree = {
				id: pendingId,
				isPending: true,
				title: task.name,
				branch: task.branch,
				description: task.description,
				taskData: {
					slug: task.slug,
					name: task.name,
					status: task.status,
				},
			};

			// Add pending worktree immediately
			setPendingWorktrees((prev) => [...prev, pendingWorktree]);
			handleCloseAddTaskModal();

			void (async () => {
				try {
					const result = await window.ipcRenderer.invoke("worktree-create", {
						workspaceId: currentWorkspace.id,
						title: task.name,
						branch: task.branch,
						createBranch: false, // Branch should already exist
						description: task.description,
					});

					if (result.success && result.worktree) {
						// Remove pending worktree
						setPendingWorktrees((prev) =>
							prev.filter((wt) => wt.id !== pendingId),
						);
						// Refresh workspace to get the real worktree
						await handleWorktreeCreated();
						setSelectedWorktreeId(result.worktree.id);
						if (result.worktree.tabs && result.worktree.tabs.length > 0) {
							handleTabSelect(result.worktree.id, result.worktree.tabs[0].id);
						}
					} else {
						// Remove pending on failure
						setPendingWorktrees((prev) =>
							prev.filter((wt) => wt.id !== pendingId),
						);
					}
				} catch (error) {
					console.error("Failed to create worktree for task:", error);
					// Remove pending on error
					setPendingWorktrees((prev) =>
						prev.filter((wt) => wt.id !== pendingId),
					);
				}
			})();
		}
	};

	const handleCreateTask = (taskData: {
		name: string;
		description: string;
		status: TaskStatus;
		assignee: string;
		branch: string;
	}) => {
		if (!currentWorkspace) return;

		// Create pending worktree for optimistic update
		const pendingId = `pending-${Date.now()}`;
		const pendingWorktree: PendingWorktree = {
			id: pendingId,
			isPending: true,
			title: taskData.name,
			branch: taskData.branch,
			description: taskData.description,
			taskData: {
				slug: "...", // Will be generated by backend
				name: taskData.name,
				status: taskData.status,
			},
		};

		// Add pending worktree immediately
		setPendingWorktrees((prev) => [...prev, pendingWorktree]);
		handleCloseAddTaskModal();

		void (async () => {
			try {
				// Create a worktree for this task
				const result = await window.ipcRenderer.invoke("worktree-create", {
					workspaceId: currentWorkspace.id,
					title: taskData.name,
					branch: taskData.branch,
					createBranch: true,
					description: taskData.description,
				});

				if (result.success && result.worktree) {
					// Remove pending worktree
					setPendingWorktrees((prev) =>
						prev.filter((wt) => wt.id !== pendingId),
					);

					// Reload workspace to get the new worktree
					await handleWorktreeCreated();

					// Switch to the new worktree
					setSelectedWorktreeId(result.worktree.id);

					// Select first tab if available
					if (result.worktree.tabs && result.worktree.tabs.length > 0) {
						handleTabSelect(result.worktree.id, result.worktree.tabs[0].id);
					}
				} else {
					// Remove pending on failure
					setPendingWorktrees((prev) =>
						prev.filter((wt) => wt.id !== pendingId),
					);
				}
			} catch (error) {
				console.error("Failed to create task/worktree:", error);
				// Remove pending on error
				setPendingWorktrees((prev) => prev.filter((wt) => wt.id !== pendingId));
			}
		})();
	};

	return {
		isAddTaskModalOpen,
		pendingWorktrees,
		openTasks,
		handleOpenAddTaskModal,
		handleCloseAddTaskModal,
		handleSelectTask,
		handleCreateTask,
	};
}

